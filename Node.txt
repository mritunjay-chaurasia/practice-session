1- What is Node.js?
    Node.js is a JavaScript runtime environment.
    It allows you to run JavaScript on server side.
    Built on Chrome’s V8 JavaScript engine.
    Single-threaded event loop → handles many connections without blocking. 

2- Node.js is single threaded then how to make it multithreaded
    we can use worker_threads module to run JS in parallel threads.
    Each worker has its own event loop, memory, and V8 instance.

3- if we delete package.lockjson file will delete from server then it is working or not
    If you delete it, the project might still run.
    But you lose version control guarantees → may break later.

4- Main Features of Node.js
    a- Asynchronous & Non-blocking I/O  
        Node.js uses an event-driven architecture.  
        Operations like file reading, DB queries, and network requests don’t block the main thread.
    b- Single threaded
        Uses the event loop to handle many clients with one thread.
        Can support thousands of concurrent connections efficiently.
    c- Built on Google’s V8 Engine
    d- Cross-platform
    e- NPM 
    f- Real-time Application Support
        Perfect for apps like chat, gaming, live updates, notifications,
        Uses WebSockets and event-driven design for instant communication.
    f- Community Support & Open Source

5- What are some disadvantages of Node.js? 
    a- Single-threaded Limitations
        While Node.js can scale horizontally (via cluster mode), a single process doesn’t take full advantage of multi-core CPUs by default.
        Requires manual setup (clusters, worker threads).
    b- Error Handling Challenges
        Asynchronous error handling is trickier compared to synchronous languages.
        Forgetting to handle errors in async code can crash the app.
    c- Not Suitable for Heavy Computation
        Event loop may become blocked by CPU-heavy operations.
        Heavy CPU tasks (like image processing, video encoding, or complex math) can block the event loop and slow down the app.
6- What are Modules?
    A module is simply a reusable block of code that can be split into separate files and imported when needed.
    Types of Modules in Node.js
    a- Core Modules (built-in)
       You don’t need to install them.(ex:fs, path, http, os)
       path- Used to work with file and directory paths.
       fs- fs module allows you to interact with the file system on your computer.
            You can read, write, update, delete, and rename files using it.
       http- module lets you create a web server and handle requests and responses.
       events- Node.js has an event-driven architecture.
                The events module allows you to create, fire, and listen for custom events.
                It uses the EventEmitter class.
       os-  The os module provides information about the operating system and hardware.
    b- Local Modules
        Modules you create yourself and use in your project.
    c- Third-party Modules
        installed via npm (ex. express, mongoose)
7- What is the difference between synchronous and asynchronous code in Node.js?
    a- Synchronous-
        Executes line by line (blocking).
        Each operation must finish before the next one starts.
        If one task takes a long time, everything else is paused until it completes.
    b- Asynchronous-
        Non-blocking.
        Operations are executed in the background.
        While waiting, Node.js can continue running other code.
        Results are handled using callbacks, promises, or async/await.

8- What is the difference between CommonJS (require) and ES Modules (import)?
        Feature	          CommonJS (CJS)	                 ES Modules (ESM)
        Syntax	          require, module.exports	         import, export
        Loading	          Synchronous	                     Asynchronous
        Export style	  module.exports = ...	            export / export default

9- What is package.json and package-lock.json?
    a- package.json- 
        Contains metadata about your project (name, version, description, author, etc.)
        Lists dependencies and scripts used in your project.
    b- package-lock.json- 
        It’s an auto-generated file created when you install dependencies with npm install.
        Ensures exact versions of dependencies are installed.
        Contains a detailed tree of all installed packages (including nested dependencies).
        Helps maintain consistency across environments (same versions in dev, staging, production).

10- Explain the role of npm in Node.js.
    It is the default package manager for Node.js.
    It allows developers to install, share, and manage libraries (packages) in a Node.js project.

11- What is the difference between npm install and npm ci?
    Use npm install → during development (flexible, updates allowed).
    Use npm ci → in CI/CD pipelines & production (faster, deterministic installs).

12- What are Node.js global objects? Give examples.
    Global Object	Description
    __dirname	    Current directory path
    __filename	    Current file path
    console	        Logging utility
    process	        Info/control about running process
    Buffer	        Binary data handling
    setTimeout / clearTimeout	Timer (delay)
    setInterval / clearInterval	Timer (repeat)
    setImmediate / clearImmediate	Run after I/O events
    require	Import modules (CJS)
    module	Info about current module

13- How does the Node.js event loop work?
    Node.js is single-threaded (only one main thread runs JavaScript).
    But it is non-blocking thanks to the event loop.
    The event loop allows Node.js to handle asynchronous operations (like file I/O, network requests, timers) without blocking the main thread.
    Event Loop Workflow:
    The event loop runs in phases. Each phase has a queue of callbacks to execute.
    a. Timers Phase
        Executes callbacks scheduled by:
        setTimeout()
        setInterval()
    b. Pending Callbacks Phase
        Executes I/O callbacks deferred from the previous loop.
    c. Poll Phase
        Important phase where:
        Node waits for incoming I/O events (network, file system).
        Executes their callbacks immediately if available.
        If nothing is pending, it may block here.
    d. Check Phase
        Executes callbacks from setImmediate().
    e. Close Callbacks Phase
        Executes close event callbacks (like socket.on("close", ...)).

14- What is non-blocking I/O in Node.js?
        Non-blocking I/O in Node.js means operations don’t stop program execution while waiting for results — instead, they use callbacks, promises, or async/await so Node can continue doing other work.

15- What is the difference between setTimeout, setInterval, and setImmediate?
    a- setTimeout:-  Executes a function after specified delay in miliseconds
    b- setInterval:- Executes a function repeatedlly at specified delay in miliseconds
    c- setImmediate:-Executes a function immediately after the curret event and before any timers like setTimeout(()=>{},0) 


16- How does Node.js handle child processes?
    Node.js uses the built-in child_process module to create and manage child processes. It provides methods like spawn, exec, execFile, and fork to run system commands or separate Node.js scripts. Child processes run outside the main event loop and communicate with the parent via events or IPC, which helps avoid blocking and enables parallel execution of heavy tasks.

17- Explain streams in Node.js and their types.
    Streams are objects in Node.js that let you read or write data continuously instead of loading it all at once.

    They are especially useful for large files, network requests, or real-time data.

    Example: Reading a 5GB file — instead of loading the whole file into memory, Node.js reads it piece by piece (chunks) using streams.

    There are 4 types: Readable (for reading), Writable (for writing), Duplex (both read & write like socket), and Transform (read/write with modification, like crypto). Streams are event-driven and help with performance and memory optimization.

18- What is buffer in Node.js?
    A Buffer in Node.js is a temporary storage area for raw binary data.

    Buffers help Node.js handle binary data directly (since JavaScript normally works with strings and doesn’t handle raw bytes well)

19-Explain middleware in Node.js (with Express).
In Express.js, middleware is a function that has access to:
    req (request object)
    res (response object)
    next (a function to pass control to the next middleware)
Middleware functions sit between the request and response cycle of an Express app.
Types of Middleware in Express:
a- Application-level middleware
    Defined using app.use() or app.METHOD()

    app.use((req, res, next) => {
    console.log("Time:", Date.now());
    next();
    });
b- Router-level middleware
    Works like app-level but applied only to specific routes.

    const router = express.Router();
    router.use((req, res, next) => {
    console.log("Router middleware");
    next();
    });

c- Built-in middleware (provided by Express)

    express.json() → parses JSON requests
    express.urlencoded() → parses URL-encoded data
    express.static() → serves static files

    app.use(express.json());
    app.use(express.static("public"));

d- Error-handling middleware
    Must have 4 parameters: (err, req, res, next)

    app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send("Something broke!");
    });

e- Third-party middleware
    Installed via npm.
    Example: morgan (logging), cors (Cross-Origin Resource Sharing).

    const morgan = require("morgan");
    app.use(morgan("dev"));

20-What is CORS and how do you handle it in Node.js?
    CORS stands for Cross-Origin Resource Sharing, a browser security feature that restricts cross-domain requests. In Node.js (with Express), we typically handle it using the cors package or by manually setting Access-Control-Allow-* headers. This tells the browser which origins, methods, and headers are allowed, and handles preflight requests for methods like POST/PUT/DELETE.

    const express = require("express");
    const cors = require("cors");
    const app = express();

    // Allow all origins (not recommended for production)
    app.use(cors());

    // OR allow specific origins
    app.use(cors({
    origin: "http://localhost:3000", // frontend origin
    methods: "GET,POST,PUT,DELETE",
    credentials: true
    }));

    app.get("/api", (req, res) => {
    res.json({ message: "CORS enabled" });
    });
    app.listen(5000, () => console.log("Server running on 5000"));


21-How do you handle errors in asynchronous code?
with promises we can use .catch() method and in modern code async/await with try catch are used 

22-What is the difference between process.nextTick() and setImmediate()? 
    Both process.nextTick() and setImmediate() schedule callbacks, but they run at different points in the Node.js event loop. process.nextTick() runs immediately after the current operation, before the event loop continues, while setImmediate() runs on the next iteration, after I/O events. process.nextTick() has higher priority but can cause event loop starvation if overused, while setImmediate() is safer for deferring execution.

    example:
    setImmediate(() => console.log("setImmediate"));
    process.nextTick(() => console.log("nextTick"));
    console.log("Start");
    output:
    Start
    nextTick
    setImmediate



23-How does clustering work in Node.js?
    Node.js runs on a single thread (event loop).
    By default, it uses only one CPU core — even if your system has 8 cores.
    Clustering allows Node.js to create multiple processes (workers) that share the same server port, enabling full use of multi-core CPUs and handling more requests in parallel.
    Benefits of Clustering:

    i- Better CPU Utilization – Uses multiple cores.
    ii- Increased Throughput – Handles more concurrent requests.
    iii- Fault Tolerance – If one worker crashes, others keep running.
    iv- Scalability – Handles high-traffic apps more efficiently.

24-What are worker threads in Node.js?
    Worker Threads in Node.js allow running JavaScript in parallel on multiple threads inside the same process. They are mainly used for CPU-intensive tasks, unlike clustering which creates separate processes for I/O scalability. Worker threads can share memory using SharedArrayBuffer and communicate via message passing, making them useful for heavy computations without blocking the event loop.

25-What are the differences between cluster, child_process, and worker_threads?
    cluster:
    have multiple process
    each process has its own memory space

    child_process:
    have multiple process
    each process has its own memory space

    worker_threads: 
    have multiple threads within one process
    can share memory (SharedArrayBuffer)

26-How does Node.js manage memory?
    Node.js manages memory using the V8 engine. Memory is divided into stack (primitives, function calls) and heap (objects, closures). The heap is further split into new space and old space, managed by V8’s garbage collector using algorithms like Scavenge and Mark-Sweep-Compact. Buffers and native modules allocate memory outside the V8 heap. Node.js provides process.memoryUsage() and debugging tools to monitor memory, and developers must avoid leaks caused by global variables, unclosed timers, or event listeners.


27-What is the difference between event-driven programming and multi-threaded programming?
    event-driven programming:- A programming paradigm where the flow of the program is determined by events (user actions like clicks, key presses, or system-generated signals like network requests).
    The program usually runs in a single thread.
    There’s an event loop that continuously listens for events.
    multi-threaded programming:-A programming model where a program can execute multiple threads of execution concurrently.


28-How can you prevent callback hell in Node.js?
    Callback hell happens when multiple nested callbacks make code unreadable and hard to maintain. We can prevent it in several ways:
    we can use promises or async/await to avoid callback hell.

29-What is the difference between synchronous and asynchronous error handling?
    Synchronous error handling deals with errors in the same call stack and can be caught directly with try/catch. Asynchronous error handling deals with errors that occur later (e.g., in callbacks, Promises, or async functions). For async code, we use callbacks with error parameters, .catch() with Promises, or try/catch with async/await.

30-How do you secure a Node.js application?
    a- Validate all user inputs (use libraries like Joi or express-validator).
        const { body } = require("express-validator");
        app.post("/user", [
        body("email").isEmail(),
        body("name").trim().escape(),
        ], handler);
    b- Use helmet to set secure HTTP headers.

    c- To secure a Node.js application, I focus on validating and sanitizing input, preventing XSS/CSRF, securing authentication and authorization with bcrypt and JWT, enforcing HTTPS, using Helmet and rate limiting for common attack prevention, handling errors safely, keeping dependencies updated, and applying deployment best practices like least privilege and monitoring.
    d- Avoid using untrusted or outdated packages.
    e- Secure Authentication & Authorization
        Use JWTs or OAuth2 for authentication.
        Store passwords with bcrypt (never in plain text).
        Implement role-based access control (RBAC).

31-What is load balancing in Node.js and how is it achieved?
Load balancing is the process of distributing incoming network traffic (HTTP requests) across multiple servers or processes so no single instance is overwhelmed. This ensures high availability, scalability, and reliability of a Node.js application.


